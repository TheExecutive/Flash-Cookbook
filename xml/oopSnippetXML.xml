<?xml version="1.0" encoding="utf-8"?>
	<snippets>
		<snippet id="creatingValueObject" course="oop">
				<name>Creating a Value Object</name>
				<difficulty>easy</difficulty>
				<keywords text="creating,value,object,value object,creating value object,oop" />
				<code>
					<![CDATA[public class CodeVO
{
	public var name:String;
	public var age:int;
	public var color:uint;
	public var condition:boolean = true (or false);
	public var num:Number;
	
public function CodeVO()
{
}]]>
				</code>
				<notes>
• Creates a new class with an extension of "vo" (ex. com.fsu.vo), once created your value object can hold variables of various data types.
• Next, create your public variables, these variables can be any data type depending on the data they need to store. While a default value is not required for  all the boolean data type does require a default value.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="creatingValueObject" course="oop">
				<name>Adding a Flex library project</name>
				<difficulty>easy</difficulty>
				<keywords text="flex library,library,flex,adding,project,oop" />
				<code>
					<![CDATA[public class CodeVO
{
	public var name:String;
	public var age:int;
	public var color:uint;
	public var condition:boolean = true (or false);
	public var num:Number;
	
public function CodeVO()
{
}]]>
				</code>
				<notes>
• Creates a new class with an extension of "vo" (ex. com.fsu.vo), once created your value object can hold variables of various data types.
• Next, create your public variables, these variables can be any data type depending on the data they need to store. While a default value is not required for  all the boolean data type does require a default value.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="implicitGetterSetter" course="oop">
				<name>Implicit Getter/Setter</name>
				<difficulty>advanced</difficulty>
				<keywords text="getter,setter,implicit,getter/setter,oop" />
				<code>
					<![CDATA[public class Button extends buttonBase
{
	private var _book:BookVO;
		
	public function Button()
	{
		super();
	}
	public function get book():BookVO
	{
		return _book;
	}
	public function set book(value:BookVO):void
	{
		_book = value;
		tfLabel.text = _book.title;
	}
}]]>
				</code>
				<notes>
• public class Button extends ButtonBase - Custom class that extends a button symbol created in the Flash IDE. 
• private var _book:BookVO - Instantiates a new variable called "_book" that is data typed as a BookVO. By data typing the variable BookVO it understands that it understands the information it will be holding will be in the form of a Value Object.
• public function Button() - Constructor class for the button object.
• super(); - refers to the parent of the button class.

// To generate your Getter/Setter highlight the "_book" variable, right click your mouse, under SOURCE click "Generate Getter/Setter", select your preferences then click OK.

• public function get book():BookVO - Gets the information from the book Value Object and returns the information as a BookVO.
• return _book; - returns the BookVO information to the _book variable.
• public function set book(value:BookVO):void - Setter for setting the book variables values to that of the BookVO. This function returns nothing.
• _book = value  - Sets the "_book" variables data equal to the value of the BookVO.
•tfLabel.text = book.title - Sets the button text equal to the title of the first book. Using a for each loop would create a button for each Value Object and set the text for each button equal to the title of each book in the VO.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="creatingButtonsWithArray" course="oop">
				<name>Creating button with Array data</name>
				<difficulty>advanced</difficulty>
				<keywords text="for each,loop,array,for,each,button,oop" />
				<code>
					<![CDATA[var show:ShowsVO;
var _shows:Array = [show1,show2,show3];
var yPos:Number = 10;
var xPos:Number = 10;
			
for each(var show:ShowsVO in _shows)
	{
		var btn:ShowButton = new ShowButton();
		addChild(btn);
		btn.showVO = show;
				
		btn.y = yPos += btn.height + 10;
		btn.x = xPos;
	}]]>
				</code>
				<notes>
• var show:ShowVO - Creates a new variable named show that holds ShowVO data.
• var _shows:Array = [show1,show2,show3] - Creates a new Array named _shows that is holding 3 show items in it.
• var yPos:Number = 10; - Creates a variable that represents the buttons Y position, data types this variable as a Number, and gives it a default value of 10.
• var xPos:Number = 10; - Creates a variable that represents the buttons X position, data types this variable as a Number, and gives it a default value of 10.

• for each(var show:ShowVO in _shows) - This for each loop goes through the "_shows" array and for every Value Object in the Array it pulls that information out and stores it in a variable called "show".
• var btn:ShowButton = new ShowButton - Creates a new variable named "btn" that is data typed as a ShowButton, which is a custom class that extends a button object created in the Flash IDE, and then sets that variable equal to a new instance of the ShowButton.
• addChild(btn) - Adds the button to the stage.
• btn.ShowVO = show; - Takes the data from the show variable and stores that in the Value Object inside the button class. By doing this the button class now has access to the data stored in the ShowVO Value Object. 

btn.y = yPos += btn.height + 10 - Sets the buttons vertical position. Starts with an itial value of 10 pixels, it then adds the button height plus 10 pixels of padding for each button that is created. This will allow the buttons to position themselves into a vertical stack
btn.x = xPos - sets the buttons horizontol position equal to value of xPos, which is 10 pixels.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="overridingFunction" course="oop">
				<name>Overriding a function</name>
				<difficulty>advanced</difficulty>
				<keywords text="function,override,overriding a function,oop" />
				<code>
					<![CDATA[override public function set name(value:String):void
{
	name = value;
}
		
override public function get name():String
{
	return name;
}]]>
				</code>
				<notes>
• override public function - Overrides a public function stored in another class. This is used so multiple classes can use the same function and return different results.
• set name(value:String):void - Setter for a name variable, accepts a value in the form of a String and returns nothing.
• name = value - Sets the name variable equal the value returned from the Getter.
• override public function get name():String - Getter for retrieving the String data used for the name variable.
• return name; - Returns the value of the String to the name variable.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="creatingAnInterface" course="oop">
				<name>Creating an Interface</name>
				<difficulty>advanced</difficulty>
				<keywords text="create,creating,interface,creating an interface,oop" />
				<code>
					<![CDATA[public interface IAnimals
{
	function makeNoise():void
	function sayHello():void
	function set name(value:String):void
	function get name():String
}]]>
				</code>
				<notes>
//Begin by creating a new interface class, give the class a package and a file name then press OK, this will create your new interface class. Remeber to begin the name of your interface classes with a capital letter "i" (I).

• public interface IAnimals - The constructor function for the Interface class.
• function makeNoise():void - Creates a public function called "makeNoise" that returns nothing.
• function sayHello():void - Creates a function call "sayHello" that returns nothing.
• function set name(value:String):void - Creates a public implicit Setter that accepts a value equal to a string and returns nothing.
• function get name():String - Creates a public implicit Getter that accepts nothing and returns a String.

//Once your interface has all the function it needs, you can then proceed to attach this interface to any class that needs access to these functions. You may then override these functions for each class so the functions work the same but return different data.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="implimentingAnInterface" course="oop">
				<name>Implimenting an Interface</name>
				<difficulty>advanced</difficulty>
				<keywords text="impliment,implimenting,interface,implimenting an interface,oop" />
				<code>
					<![CDATA[public class Duck extends DuckBase implements IAnimals]]>
				</code>
				<notes>
• When creating a class that needs to impliment an Interface, simply click "Add.." in the class creation menu, this will display a search box. 
• Type the name of your interface into the search box, the list updates dynamically so your interface should appear after only typing a few letter.
• Click the Interface you want to include and and click "OK".
• Click "Finish" in the class creation menu and your new class will be created and will extend the Interface you chose to include.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="creatingAConstant" course="oop">
				<name>Creating a Constant</name>
				<difficulty>advanced</difficulty>
				<keywords text="create,creating,constant,static,public,oop" />
				<code>
					<![CDATA[public static const CLASS_NAME:String = "OOP";]]>
				</code>
				<notes>
• public static const - Creates a new public static constant. Static constants are variables who value does not change and can be accessed throughout the run of the program.
• CLASS_NAME:String - CLASS_NAME is the name of constant, notice it uses all uppercase letter and underscores in place of spaces or camelCase. Is data typed as a String.
• = "OOP"; - Is the string value for the constant, this value will not change throughout the run of the program. However, if you need to chagne the value of the constant you can change it here.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="useCapture" course="oop">
				<name>Events with useCapture</name>
				<difficulty>advanced</difficulty>
				<keywords text="event,events,capture,usecapture,oop" />
				<code>
					<![CDATA[object.addEventListener(event.EVENT, doSomething, useCapture;]]>
				</code>
				<notes>
• object.addEventListner - Adds an event listener to an object.
• event.EVENT - The event the listener responds to, can be any event in the object event list.
• doSomething - The function that would run once the event has taken place.
• useCapture - Indicates that the user wishes to initiate capture. After initiating capture, all events of the specified type will be dispatched to the registered listener before being dispatched to any EventTargets beneath it in the DOM tree.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="inheritence" course="oop">
				<name>Inheritence: Extending another class</name>
				<difficulty>advanced</difficulty>
				<keywords text="inheritence,class,extend,extending,oop" />
				<code>
					<![CDATA[	public class Object extends ObjectBase
{
	public function object()
	{
		super();
	}
	public function doSomething():void
	{
			//actions to be performed
	}
	public function doSometingElse():void
	{
			//actions be performed
	}
}

//Next creates a new class that needs the same functionality and extend the first class you created (object)

public class NewObject extends Object
{
	public function MaxMover()
	{
		super();
	}
	public function doSomething():void
	{
		//new actions to be performed
	}
	public function doSomethingElse():void
	{
		//new actions to be performed
	}
}]]>
				</code>
				<notes>
• public class Object extends ObjectBase - A custom class that extends a object created in the Flash IDE.
• public function object() - The class constructor.
• super() - Extends the parents functionality to this class.
• public function doSomething() / doSomethingElse() - Functions the class performs, made public so that other classes can access these functions as well.

• public class NewObject extends Object - Creates a new class named "NewObject" that extends the "Object" class created earlier. By allowing the new class to extend the previous class it gains all the functionality of the previous class through the concept of Inheritence.
• public function doSomething():void -Public function inherited from the class the NewObject class is extending. These functions will performt he same actions for any class they extend.
• public function doSomethingElse():void - Public function inherited from the class the NewObject class is extending. These functions will performt he same actions for any class they extend.
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="polymorphism" course="oop">
				<name>Polymorphism</name>
				<difficulty>advanced</difficulty>
				<keywords text="inheritence,class,extend,extending,oop" />
				<code>
					<![CDATA[	public class Object extends ObjectBase
{
	public function object()
	{
		super();
	}
	public function doSomething():void
	{
			//actions to be performed
	}
	public function doSometingElse():void
	{
			//actions be performed
	}
}

//Next creates a new class that needs the same functionality and extend the first class you created (object)

public class NewObject extends Object
{
	public function MaxMover()
	{
		super();
	}
	override public function doSomething():void
	{
		//new actions to be performed
	}
	override public function doSomethingElse():void
	{
		//new actions to be performed
	}
}]]>
				</code>
				<notes>
• public class Object extends ObjectBase - A custom class that extends a object created in the Flash IDE.
• public function object() - The class constructor.
• super() - Extends the parents functionality to this class.
• public function doSomething() / doSomethingElse() - Functions the class performs, made public so that other classes can access these functions as well.

• public class NewObject extends Object - Creates a new class named "NewObject" that extends the "Object" class created earlier. By allowing the new class to extend the previous class it gains all the functionality of the previous class through the concept of Inheritence.
• override public function doSomething():void - Overrides the inherited function, this allows the function to work in the same manner but produce different results depending on the code inside of the function. (Polymorphism)
• override public function doSomethingElse():void - Overrides the inherited function, this allows the function to work in the same manner but produce different results depending on the code inside of the function. (Polymorphism)
				</notes>
				<resources>

				</resources>
		</snippet>
		<snippet id="flexLibraryProject" course="oop">
				<name>Resource: Adding a Flex library project</name>
				<difficulty>easy</difficulty>
				<keywords text="flex library,library,flex,adding,project,oop" />
				<code>
					<![CDATA[//By adding Flex LIbraries to your projects it allows you to utilize assets such a "Reusable code library" in any project you are working on. There is no code for this so just follow the steps below to add a library to your project.]]>
				</code>
				<notes>
• Beging by right-clicking on the projects main container folder, at the bottom of the pop up menu you will see an option called "Properties" click on properties to open properties menu.
• Next, click on the "Actionscript Build Path" option in the left side menu.
• From here you can add projects, SWC folders, or single SWCs. To add a library such as a "Reusable code library" select the "Add Project" option.
• If your code libraries are loaded into the Flash Builder the a box should pop up with all the Flex Projects Flex Builder can find. 
• Select the library you would like to add to your project and click OK.
• Lastly, click OK in the build path menu box. Thats it, your Flex Library has been added to your project and you may now utilize any reusable code you have in your library in the project you added it to.
				</notes>
				<resources>

				</resources>
		</snippet>
	</snippets>